using System.Windows.Input;

internal class Program
{
    private static void Main(string[] args)
    {
        // основы ооп
        // банда четырех (одна из канонов среди книг про ооп и паттерны)
        // абстракция - каждый класс описывает какую-то задачу, при этом
        // нет нужды описывать задачу целиком и полностью до мельчайших подробностей
        // при создании класса следует подумать, что требуется и отбросить все остальное
        // 1. Наследование - возможность создавать новые классы на основе
        // уже существующих
        // наследование помечается через : после имени класса
        // можно наследовать 1 класс и множество интерфейсов
        // при наследовании класс-наследник получает в свое распоряжение
        // все неприватные элементы класс-родителя
        Cat cat = new Cat();
        cat.Roar();
        cat.Print();

        // наследуемый класс можно привести к типу класса-родителя и 
        // работать с объектом так, как будто это и есть изначально родительский класс
        Animal animal = new Cat();
        animal.Roar();

        // мы можем проверить, ведет ли ссылка на объект определенного вида
        // с помощью ключевых слов is и as
        // c помощью is мы проверяем, что ссылка animal
        // действительно указывает на объект типа Cat
        // если это так, то создается еще одна ссылка target типа Cat
        if (animal is Cat target)
            target.Print();

        // безопасное преобразование типов
        // если ссылка animal действительно ведет на объект типа Cat
        // то target2 тоже получит эту ссылку, в противном случае
        // target2 будет иметь значение null
        Cat target2 = animal as Cat;
        // обязательно проверяем на null
        if (target2 != null)
            target2.Print();
        // или так: ?. это короткий оператор с проверкой на null
        target2?.Print();

        // 1. рекомендуется наследовать абстрактные классы
        // 2. классы-наследники не должны ломать логику работы классов-родителей


        // утка - универсал
        Duck duck = new();
        duck.Roar();
        duck.Swim();
        // можно проверять наличие реализованных интерфейсов также
        // как и класс-родитель
        if (duck is ICanFly fly)
            fly.Fly();

        Test123 test = new Test123();
        test.Test(); //вызов реализации метода 
        ((ITest)test).Test2(); // вызов реализации метода из интерфейса

        // 2. Полиморфизм (один интерфейс - множество реализаций)
        // полиморфизм возможен за счет интерфейсов, за счет конструкторов и методов
        // (с похожей сигнатурой, разница только в аргументах)
        // также для полиморфизма используются обобщения (дженерики)

        Animal[] animals = new Animal[3];
        animals[0] = new Cat();
        animals[1] = new Dog();
        animals[2] = new Duck();

        foreach (Animal a in animals)
            a.Roar(); // один и тот же метод, но разная реализация в разных классах

        // 3. Инкапсуляция - несколько возможных интерпретаций
        // 3.1 сокрытие состояния и/или поведения внутри класса
        // 3.2 объединение кода и данных внутри класса
        // 3.3 защита внутреннего состояния класса от внешних посягательств
        // понятие черного ящика: - мы знаем интерфейс, но не знаем что внутри
        // 3.4 работа класса происходит внутри класса
        // пример инкапсуляции - реализация некоторого контейнера,
        // который умеет обрабатывать определенные объекты
        // например он их может создавать, или принимать и хранить до востребования

        var factory = new AnimalFactory();
        Animal newAnimal = factory.Create();
        // c внешней точки зрения, мы не знаем как работает фабрика
        // откуда она берет этих животных, но мы знаем, что если
        // попросить (Create), мы получим животное (Animal)

        // если нам придется давать фабрике полные инструкции
        // на тему того, откуда брать животных, как их создавать,
        // какие настройки для этого использовать - тут должны появляться вопросы - есть инкапсуляция или нет
        
        // если нам придется создавать!!! животных вручную и отдавать их фабрике
        // тогда это будет нарушением инкапсуляции

        // если у класса есть поведение, то с одной стороны
        // это поведение может быть размазано по другим классам
        // с другой стороны, выполнение этого поведения не должно 
        // вытекать за рамки класса
        // как это понять - мы можем настраивать объект класса с помощью
        // конструкторов, методов и тп, соответственно мы можем
        // передать внутрь класса другие объекты, которые внутри будут 
        // использоваться

        // если мы начинаем управлять внутренним! содержимым и поведением
        // класса извне! его из других объектов, тогда это нарушение инкапсуляции

        // у класса как правило есть одно назначение
        // и если это назначение связано с поведением, то оно 
        // должно выполняться внутри класса
    }


}

// abstract - помеченный этим словом класс может объявлять абстрактные
// методы и свойства (т.е. без реализации), нельзя создать экземпляр
// абстрактного класса
abstract class Animal
{
    private double weight;

    // создание конструктора, который нужно вызвать в классе-наследнике
    protected Animal(string type)
    {
        Type = type;
    }

    public string Type { get; set; }
    // внутри абстрактного класса можно создавать методы без реализации
    public abstract void Roar();

    public void AddWeight(double weight)
    {
        this.weight += weight;
    }

    // виртуальные методы можно переопределить в классе-наследнике
    public virtual void Print()
    {
        Console.WriteLine(Type);
        Console.WriteLine("вес: " + weight + "кг");
    }
}

// : Animal - наследование класса Animal
class Cat : Animal
{
    public void MakeNoise()
    {
        Console.WriteLine("Тыгыдык");
    }
    // override используется для переопределение виртуальных методов
    // или реализации абстрактных методов
    public override void Roar()
    {
        Console.WriteLine("Мяу");
    }

    // вызов конструктора в родительском классе 
    // происходит через слово base
    public Cat() : base("Кошка домашняя")
    {
        AddWeight(1.0);
    }

    // c помощью override мы можем переопределить метод родительского класса
    public override void Print()
    {
        // c помощью base в методе можно вызвать базовую реализацию метода
        base.Print();
        Console.WriteLine("Средство для обдирания обоев");
    }
}

// котопес
class Dog : Cat, ICanSwim
{
    public override void Roar()
    {
        // это что-то странное, что ломает логику в принципе
        // и логику родительского класса в частности
        // поэтому это плохо и неправильно
        AddWeight(2.0);
    }

    public void Swim()
    {
        Console.WriteLine("буль буль (стиль топора)");
    }
}

// sealed - закрытый класс (с точки зрения наследования)
sealed class Duck : Animal, ICanFly, ICanSwim
{
    public Duck() : base("Утка")
    {

    }

    public void Fly()
    {
        Console.WriteLine("Утка летать");
    }

    public override void Roar()
    {
        Console.WriteLine("Утка орать");
    }

    public void Swim()
    {
        Console.WriteLine("Утка плыть");
    }
}
/*
// не скомпилируется
class MyDuck : Duck
{ 

}
*/
// интерфейсы определяют публичные члены классы, при этом реализацию должны
// предоставить классы, которые будут реализовывать интерфейсы
interface ICanSwim
{
    void Swim();
}

interface ICanFly
{
    void Fly();
}

// внутри интерфейса можно объявлять: методы, события, свойства
// модификаторы видимости указываются, начиная с версии C# 8.0, методы не могут статичными
// когда класс реализует интерфейс, все члены интерфейса объявляются
// в классе как публичные!
interface ITest
{
    int Count { get; set; }
    event EventHandler<Animal> AnimalChanged;
    public void Test();
    public void Test2()
    {
        Console.WriteLine("Метод реализован в интерфейсе!!");
    }
}

class Test123 : ITest
{
    public int Count { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }

    public event EventHandler<Animal> AnimalChanged;

    public void Test()
    {

    }

    public int Sum(int x, int y)
    {
        return x + y;
    }

    public double Sum(double x, double y)
    {
        return x + y;
    }

    // можно переопределить реализацию метода из интерфейса
    // указав такую же сигнатуру метода
    //public void Test2()
    //{
    //    Console.WriteLine("Реализация test2 из класса ");
    //}
}

class AnimalFactory
{
    Random rand = new Random();
    public Animal Create()
    {
        int rnd = rand.Next(0, 3);
        Animal result;
        switch (rnd)
        {
            case 0: result = new Duck(); break;
            case 1: result = new Dog(); break;
            default:
                result = new Cat();
                break;
        }

        return result;
    }
}