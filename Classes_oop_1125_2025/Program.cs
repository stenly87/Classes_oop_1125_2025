using System.Windows.Input;

internal class Program
{
    private static void Main(string[] args)
    {
        // основы ооп
        // банда четырех (одна из канонов среди книг про ооп и паттерны)
        // абстракция - каждый класс описывает какую-то задачу, при этом
        // нет нужды описывать задачу целиком и полностью до мельчайших подробностей
        // при создании класса следует подумать, что требуется и отбросить все остальное
        // 1. Наследование - возможность создавать новые классы на основе
        // уже существующих
        // наследование помечается через : после имени класса
        // можно наследовать 1 класс и множество интерфейсов
        // при наследовании класс-наследник получает в свое распоряжение
        // все неприватные элементы класс-родителя
        Cat cat = new Cat();
        cat.Roar();
        cat.Print();

        // наследуемый класс можно привести к типу класса-родителя и 
        // работать с объектом так, как будто это и есть изначально родительский класс
        Animal animal = new Cat();
        animal.Roar();

        // мы можем проверить, ведет ли ссылка на объект определенного вида
        // с помощью ключевых слов is и as
        // c помощью is мы проверяем, что ссылка animal
        // действительно указывает на объект типа Cat
        // если это так, то создается еще одна ссылка target типа Cat
        if (animal is Cat target)
            target.Print();

        // безопасное преобразование типов
        // если ссылка animal действительно ведет на объект типа Cat
        // то target2 тоже получит эту ссылку, в противном случае
        // target2 будет иметь значение null
        Cat target2 = animal as Cat;
        // обязательно проверяем на null
        if (target2 != null)
            target2.Print();
        // или так: ?. это короткий оператор с проверкой на null
        target2?.Print();

        // 1. рекомендуется наследовать абстрактные классы
        // 2. классы-наследники не должны ломать логику работы классов-родителей

        // утка - универсал
        Duck duck = new();
        duck.Roar();
        duck.Swim();
        // можно проверять наличие реализованных интерфейсов также
        // как и класс-родитель
        if (duck is ICanFly fly)
            fly.Fly();
    }

    
}

// abstract - помеченный этим словом класс может объявлять абстрактные
// методы и свойства (т.е. без реализации), нельзя создать экземпляр
// абстрактного класса
abstract class Animal
{
    private double weight;

    // создание конструктора, который нужно вызвать в классе-наследнике
    protected Animal(string type)
    {
        Type = type;
    }

    public string Type { get; set; }
    // внутри абстрактного класса можно создавать методы без реализации
    public abstract void Roar();

    public void AddWeight(double weight)
    { 
        this.weight += weight; 
    }

    // виртуальные методы можно переопределить в классе-наследнике
    public virtual void Print()
    {
        Console.WriteLine(Type);
        Console.WriteLine("вес: " + weight + "кг");
    }
}

// : Animal - наследование класса Animal
class Cat : Animal
{
    public void MakeNoise()
    {
        Console.WriteLine("Тыгыдык");
    }
    // override используется для переопределение виртуальных методов
    // или реализации абстрактных методов
    public override void Roar()
    {
        Console.WriteLine("Мяу");
    }

    // вызов конструктора в родительском классе 
    // происходит через слово base
    public Cat() : base("Кошка домашняя")
    {
        AddWeight(1.0);
    }

    // c помощью override мы можем переопределить метод родительского класса
    public override void Print()
    {
        // c помощью base в методе можно вызвать базовую реализацию метода
        base.Print();
        Console.WriteLine("Средство для обдирания обоев");
    }
}

// котопес
class Dog : Cat, ICanSwim
{
    public override void Roar()
    {
        // это что-то странное, что ломает логику в принципе
        // и логику родительского класса в частности
        // поэтому это плохо и неправильно
        AddWeight(2.0);
    }

    public void Swim()
    {
        Console.WriteLine("буль буль (стиль топора)");
    }
}

class Duck : Animal, ICanFly, ICanSwim
{
    public Duck (): base("Утка")
    {

    }

    public void Fly()
    {
        Console.WriteLine("Утка летать");
    }

    public override void Roar()
    {
        Console.WriteLine("Утка орать");
    }

    public void Swim()
    {
        Console.WriteLine("Утка плыть");
    }
}

// интерфейсы определяют публичные члены классы, при этом реализацию должны
// предоставить классы, которые будут реализовывать интерфейсы
interface ICanSwim
{
    void Swim();
}

interface ICanFly
{
    void Fly();
}